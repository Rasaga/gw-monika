<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>guesswho - Ramon Sanchez Garcia: Referencia de la Clase QuienEsQuien</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">guesswho - Ramon Sanchez Garcia
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Buscar');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Página&#160;principal</span></a></li>
      <li class="current"><a href="annotated.html"><span>Clases</span></a></li>
      <li><a href="files.html"><span>Archivos</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Buscar" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Lista&#160;de&#160;clases</span></a></li>
      <li><a href="classes.html"><span>Índice&#160;de&#160;clases</span></a></li>
      <li><a href="functions.html"><span>Miembros&#160;de&#160;las&#160;clases</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Métodos públicos</a> &#124;
<a href="#friends">Amigas</a> &#124;
<a href="classQuienEsQuien-members.html">Lista de todos los miembros</a>  </div>
  <div class="headertitle">
<div class="title">Referencia de la Clase QuienEsQuien</div>  </div>
</div><!--header-->
<div class="contents">

<p>T.D.A. <a class="el" href="classQuienEsQuien.html" title="T.D.A. QuienEsQuien. ">QuienEsQuien</a>.  
 <a href="classQuienEsQuien.html#details">Más...</a></p>

<p><code>#include &lt;<a class="el" href="quienesquien_8h_source.html">quienesquien.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Métodos públicos</h2></td></tr>
<tr class="memitem:a2942486f1ff134fec70e5d21d7916a2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2942486f1ff134fec70e5d21d7916a2e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a2942486f1ff134fec70e5d21d7916a2e">QuienEsQuien</a> ()</td></tr>
<tr class="memdesc:a2942486f1ff134fec70e5d21d7916a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor basico de la clase. <br /></td></tr>
<tr class="separator:a2942486f1ff134fec70e5d21d7916a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362b7513eba83170d18d98946bc01d87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a362b7513eba83170d18d98946bc01d87">QuienEsQuien</a> (const <a class="el" href="classQuienEsQuien.html">QuienEsQuien</a> &amp;quienEsQuien)</td></tr>
<tr class="memdesc:a362b7513eba83170d18d98946bc01d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor de copia.  <a href="#a362b7513eba83170d18d98946bc01d87">Más...</a><br /></td></tr>
<tr class="separator:a362b7513eba83170d18d98946bc01d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade80093df9e450c6e37e8992da112a70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade80093df9e450c6e37e8992da112a70"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#ade80093df9e450c6e37e8992da112a70">~QuienEsQuien</a> ()</td></tr>
<tr class="memdesc:ade80093df9e450c6e37e8992da112a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor del pregunta. <br /></td></tr>
<tr class="separator:ade80093df9e450c6e37e8992da112a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17703bc3277c2846fa67f857894366cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17703bc3277c2846fa67f857894366cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a17703bc3277c2846fa67f857894366cd">limpiar</a> ()</td></tr>
<tr class="memdesc:a17703bc3277c2846fa67f857894366cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vacia todos los datos del <a class="el" href="classQuienEsQuien.html" title="T.D.A. QuienEsQuien. ">QuienEsQuien</a> receptor. <br /></td></tr>
<tr class="separator:a17703bc3277c2846fa67f857894366cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a4139787934cca03996687460935dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQuienEsQuien.html">QuienEsQuien</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#ae7a4139787934cca03996687460935dd">operator=</a> (const <a class="el" href="classQuienEsQuien.html">QuienEsQuien</a> &amp;quienEsQuien)</td></tr>
<tr class="memdesc:ae7a4139787934cca03996687460935dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sobrecarga del operador de asignacion.  <a href="#ae7a4139787934cca03996687460935dd">Más...</a><br /></td></tr>
<tr class="separator:ae7a4139787934cca03996687460935dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a107f9ffee5bf65cc0884fa39d66cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67a107f9ffee5bf65cc0884fa39d66cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a67a107f9ffee5bf65cc0884fa39d66cf">mostrar_estructuras_leidas</a> ()</td></tr>
<tr class="memdesc:a67a107f9ffee5bf65cc0884fa39d66cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escribe en la salida estandard las estructuras atributos, personajes y tablero. <br /></td></tr>
<tr class="separator:a67a107f9ffee5bf65cc0884fa39d66cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af507d54ac1d74f98ee5694fccf0406"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2af507d54ac1d74f98ee5694fccf0406"></a>
<a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a2af507d54ac1d74f98ee5694fccf0406">crear_arbol</a> ()</td></tr>
<tr class="memdesc:a2af507d54ac1d74f98ee5694fccf0406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Este metodo construye el arbol de preguntas para todos los personajes del tablero. <br /></td></tr>
<tr class="separator:a2af507d54ac1d74f98ee5694fccf0406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0949bd026c2beeaacbf36fd0ba6fc3a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a0949bd026c2beeaacbf36fd0ba6fc3a9">usar_arbol</a> (<a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt; arbol_nuevo)</td></tr>
<tr class="memdesc:a0949bd026c2beeaacbf36fd0ba6fc3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sustituye el arbol actual por el arbol pasado por parmetro.  <a href="#a0949bd026c2beeaacbf36fd0ba6fc3a9">Más...</a><br /></td></tr>
<tr class="separator:a0949bd026c2beeaacbf36fd0ba6fc3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381bcd553e7c0231bb1f33e67ae3c653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a381bcd553e7c0231bb1f33e67ae3c653">iniciar_juego</a> ()</td></tr>
<tr class="memdesc:a381bcd553e7c0231bb1f33e67ae3c653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inicializa el juego.  <a href="#a381bcd553e7c0231bb1f33e67ae3c653">Más...</a><br /></td></tr>
<tr class="separator:a381bcd553e7c0231bb1f33e67ae3c653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16816dd39d95ad489e44469f89fabbd4"><td class="memItemLeft" align="right" valign="top">set&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a16816dd39d95ad489e44469f89fabbd4">informacion_jugada</a> (<a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node jugada_actual)</td></tr>
<tr class="memdesc:a16816dd39d95ad489e44469f89fabbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dado un estado del tablero devuelve los nombres de los personajes que aun no han sido tumbados en el tablero.  <a href="#a16816dd39d95ad489e44469f89fabbd4">Más...</a><br /></td></tr>
<tr class="separator:a16816dd39d95ad489e44469f89fabbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fd517d09369436bcfc6914dd964e6a"><td class="memItemLeft" align="right" valign="top">set&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a60fd517d09369436bcfc6914dd964e6a">union_jugadas</a> (set&lt; string &gt; primera, set&lt; string &gt; segunda)</td></tr>
<tr class="memdesc:a60fd517d09369436bcfc6914dd964e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo auxiliar, utilizado para unir dos set.  <a href="#a60fd517d09369436bcfc6914dd964e6a">Más...</a><br /></td></tr>
<tr class="separator:a60fd517d09369436bcfc6914dd964e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8c88bef5056bdd366810d180d29d94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b8c88bef5056bdd366810d180d29d94"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a1b8c88bef5056bdd366810d180d29d94">escribir_arbol_completo</a> () const </td></tr>
<tr class="memdesc:a1b8c88bef5056bdd366810d180d29d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escribe el arbol generado en la salida estandard. <br /></td></tr>
<tr class="separator:a1b8c88bef5056bdd366810d180d29d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010586f119ad0966d35c64382a64e3bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a010586f119ad0966d35c64382a64e3bc">eliminar_nodos_redundantes</a> ()</td></tr>
<tr class="memdesc:a010586f119ad0966d35c64382a64e3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo que modifica el arbol de preguntas para que haya preguntas redundantes.  <a href="#a010586f119ad0966d35c64382a64e3bc">Más...</a><br /></td></tr>
<tr class="separator:a010586f119ad0966d35c64382a64e3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0868e2c4013917db4cd79474c42e0386"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a0868e2c4013917db4cd79474c42e0386">eliminar_nodos_redundantes</a> (<a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node n)</td></tr>
<tr class="memdesc:a0868e2c4013917db4cd79474c42e0386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo que modifica el arbol de preguntas para que haya preguntas redundantes.  <a href="#a0868e2c4013917db4cd79474c42e0386">Más...</a><br /></td></tr>
<tr class="separator:a0868e2c4013917db4cd79474c42e0386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b283af407756659fb75fba1725f84c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a3b283af407756659fb75fba1725f84c0">tengo_hijos_nulos</a> (<a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node n)</td></tr>
<tr class="memdesc:a3b283af407756659fb75fba1725f84c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo auxiliar para comprobar si un nodo tiene hijos nulos.  <a href="#a3b283af407756659fb75fba1725f84c0">Más...</a><br /></td></tr>
<tr class="separator:a3b283af407756659fb75fba1725f84c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420bdb4aa9eafeac062279e3968f8f1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a420bdb4aa9eafeac062279e3968f8f1f">ajuste_nodos_nulos</a> (<a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node n)</td></tr>
<tr class="memdesc:a420bdb4aa9eafeac062279e3968f8f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo para ajustar los hijos nulos.  <a href="#a420bdb4aa9eafeac062279e3968f8f1f">Más...</a><br /></td></tr>
<tr class="separator:a420bdb4aa9eafeac062279e3968f8f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae999ad6c20f9ebf6a710060b99741126"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#ae999ad6c20f9ebf6a710060b99741126">profundidad_promedio_hojas</a> ()</td></tr>
<tr class="memdesc:ae999ad6c20f9ebf6a710060b99741126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Este metodo permite calcular la media de la profundidad de las hojas del arbol. Este valor representa el numero (promedio) de preguntas necesarias para adivinar cada personaje. A menor profundidad promedio, mejor solucion. Esta metrica es un indicador para evaluar la calidad de vuestra solucion.  <a href="#ae999ad6c20f9ebf6a710060b99741126">Más...</a><br /></td></tr>
<tr class="separator:ae999ad6c20f9ebf6a710060b99741126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39024ba42b698f04960add57b177aa9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a39024ba42b698f04960add57b177aa9f">contar</a> (<a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node nodo)</td></tr>
<tr class="memdesc:a39024ba42b698f04960add57b177aa9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo para contar el numero de nodos a partir de un nodo.  <a href="#a39024ba42b698f04960add57b177aa9f">Más...</a><br /></td></tr>
<tr class="separator:a39024ba42b698f04960add57b177aa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1535e054736d9920e8859b21697e372e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a1535e054736d9920e8859b21697e372e">total_profundidad</a> (<a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node n, int acum)</td></tr>
<tr class="memdesc:a1535e054736d9920e8859b21697e372e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo para obtener el total de profundidades de cada nodo.  <a href="#a1535e054736d9920e8859b21697e372e">Más...</a><br /></td></tr>
<tr class="separator:a1535e054736d9920e8859b21697e372e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab84d08b95044e18858aae863337ea1"><td class="memItemLeft" align="right" valign="top">pair&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#abab84d08b95044e18858aae863337ea1">info_jugada</a> (<a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node n, bool valor)</td></tr>
<tr class="memdesc:abab84d08b95044e18858aae863337ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo que devuelve un par de valores con la informacion de la jugada actual.  <a href="#abab84d08b95044e18858aae863337ea1">Más...</a><br /></td></tr>
<tr class="separator:abab84d08b95044e18858aae863337ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15de9675449659e796f66e6f3ca81d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#aa15de9675449659e796f66e6f3ca81d9">insertar_jugador</a> (string nombre, vector&lt; bool &gt; nuevo)</td></tr>
<tr class="memdesc:aa15de9675449659e796f66e6f3ca81d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo para insertar un jugador a mi arbol.  <a href="#aa15de9675449659e796f66e6f3ca81d9">Más...</a><br /></td></tr>
<tr class="separator:aa15de9675449659e796f66e6f3ca81d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca83ec923ee214026bdae93989063e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a8ca83ec923ee214026bdae93989063e4">esta_vector</a> (vector&lt; bool &gt; prueba)</td></tr>
<tr class="memdesc:a8ca83ec923ee214026bdae93989063e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo auxiliar usando por insertar_jugador que comprueba si un vector booleano existe o no en el tablero.  <a href="#a8ca83ec923ee214026bdae93989063e4">Más...</a><br /></td></tr>
<tr class="separator:a8ca83ec923ee214026bdae93989063e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af1faf763f8f96ee2f346928b256460"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a0af1faf763f8f96ee2f346928b256460">eliminar_jugador</a> (string nombre)</td></tr>
<tr class="memdesc:a0af1faf763f8f96ee2f346928b256460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo que elimina un jugador pasado por parametro de un arbol.  <a href="#a0af1faf763f8f96ee2f346928b256460">Más...</a><br /></td></tr>
<tr class="separator:a0af1faf763f8f96ee2f346928b256460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94094336e901975020d712a2bfc2b963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a94094336e901975020d712a2bfc2b963">crear_arbol_mejorado</a> ()</td></tr>
<tr class="memdesc:a94094336e901975020d712a2bfc2b963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funcion que crea un nuevo arbol mejorado. Para ello, utiliza la entropia del tablero para crear un nuevo arbol. Cada pregunta que se crea nuevamente, dependera del valor booleano y de la entropia de los valores que queden, que no hayan sido usados. Para ello, al contrario de como hice el arbol normal, use estructuras auxiliares. Para hacer uso de esto, ademas implemente varios metodos adicionales: posicion_entropia(matriz,atri), hijo_izquierda(matriz,posicion,atri,n,per), hijo_izquierda(matriz,posicion,atri,n,per); NOTA: Podria haber hecho una funcion para llamar a estos dos ultimos metodos. Por falta de tiempo, junto a otros, lo he dejado asi.  <a href="#a94094336e901975020d712a2bfc2b963">Más...</a><br /></td></tr>
<tr class="separator:a94094336e901975020d712a2bfc2b963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0444a0f0d2f9afcb92df87ced126a42c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a0444a0f0d2f9afcb92df87ced126a42c">posicion_entropia</a> (vector&lt; vector&lt; bool &gt;&gt; matriz, vector&lt; string &gt; atri)</td></tr>
<tr class="memdesc:a0444a0f0d2f9afcb92df87ced126a42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo que devuelve la posicion del atributo con mejor entropia.  <a href="#a0444a0f0d2f9afcb92df87ced126a42c">Más...</a><br /></td></tr>
<tr class="separator:a0444a0f0d2f9afcb92df87ced126a42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b6b326775cc6f4967cd50b31736fc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a54b6b326775cc6f4967cd50b31736fc1">hijo_izquierda</a> (vector&lt; vector&lt; bool &gt;&gt; matriz, int posicion, vector&lt; string &gt; atri, <a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node n, vector&lt; string &gt; per)</td></tr>
<tr class="memdesc:a54b6b326775cc6f4967cd50b31736fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo que inserta un hijo en la izquierda.  <a href="#a54b6b326775cc6f4967cd50b31736fc1">Más...</a><br /></td></tr>
<tr class="separator:a54b6b326775cc6f4967cd50b31736fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e83a35f30d0f8a7bd171c58db182a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a08e83a35f30d0f8a7bd171c58db182a7">hijo_derecha</a> (vector&lt; vector&lt; bool &gt;&gt; matriz, int posicion, vector&lt; string &gt; atri, <a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node n, vector&lt; string &gt; per)</td></tr>
<tr class="memdesc:a08e83a35f30d0f8a7bd171c58db182a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo que inserta un hijo en la derecha.  <a href="#a08e83a35f30d0f8a7bd171c58db182a7">Más...</a><br /></td></tr>
<tr class="separator:a08e83a35f30d0f8a7bd171c58db182a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b183ac890b8aefa1008e54fcd2704d5"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a6b183ac890b8aefa1008e54fcd2704d5">pelador</a> (vector&lt; vector&lt; bool &gt;&gt; matriz, int posicion, bool valor, vector&lt; string &gt; &amp;per)</td></tr>
<tr class="memdesc:a6b183ac890b8aefa1008e54fcd2704d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Se encarga de crear una nueva matriz a partir de otra, la posicion del valor, el valor en cuestion (0 o 1) y un vector de persojes.  <a href="#a6b183ac890b8aefa1008e54fcd2704d5">Más...</a><br /></td></tr>
<tr class="separator:a6b183ac890b8aefa1008e54fcd2704d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0763b7ac0c24a3c54c2affaabe1f017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#ac0763b7ac0c24a3c54c2affaabe1f017">tablero_aleatorio</a> (int numero_de_personajes)</td></tr>
<tr class="memdesc:ac0763b7ac0c24a3c54c2affaabe1f017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rellena los datos del <a class="el" href="classQuienEsQuien.html" title="T.D.A. QuienEsQuien. ">QuienEsQuien</a> con un tablero calculado aleatoriamente.  <a href="#ac0763b7ac0c24a3c54c2affaabe1f017">Más...</a><br /></td></tr>
<tr class="separator:ac0763b7ac0c24a3c54c2affaabe1f017"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Amigas</h2></td></tr>
<tr class="memitem:a2d1e36c1b1d93621e8544d645cfff44c"><td class="memItemLeft" align="right" valign="top">istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a2d1e36c1b1d93621e8544d645cfff44c">operator&gt;&gt;</a> (istream &amp;is, <a class="el" href="classQuienEsQuien.html">QuienEsQuien</a> &amp;quienEsQuien)</td></tr>
<tr class="memdesc:a2d1e36c1b1d93621e8544d645cfff44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operador de extraccion de flujo.  <a href="#a2d1e36c1b1d93621e8544d645cfff44c">Más...</a><br /></td></tr>
<tr class="separator:a2d1e36c1b1d93621e8544d645cfff44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd056740c595bda2964d68dc262a639"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuienEsQuien.html#a0fd056740c595bda2964d68dc262a639">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="classQuienEsQuien.html">QuienEsQuien</a> &amp;quienEsQuien)</td></tr>
<tr class="memdesc:a0fd056740c595bda2964d68dc262a639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operador de insercion de flujo.  <a href="#a0fd056740c595bda2964d68dc262a639">Más...</a><br /></td></tr>
<tr class="separator:a0fd056740c595bda2964d68dc262a639"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descripción detallada</h2>
<div class="textblock"><p>T.D.A. <a class="el" href="classQuienEsQuien.html" title="T.D.A. QuienEsQuien. ">QuienEsQuien</a>. </p>
<dl class="section author"><dt>Autor</dt><dd>Ramon Sanchez Garcia</dd></dl>
<p>Conjunto de personajes con sus atributos. Lo primero que he hecho ha sido hacer el árbol de forma normal. Creo mi arbol, como explico en la seccion "crear_arbol", usando los datos leidos.</p>
<p>Se ha implementado tambien una mejora que crea el arbol usando entropia. Para ver como lo he hecho, consulta la seccion "crear_arbol_mejorado".</p>
<p>Finalmente he implementado tambien los metodos obligatorios y opcionales. Toda la informacion de como los he hecho lo explico en sus correspondientes metodos. </p>
</div><h2 class="groupheader">Documentación del constructor y destructor</h2>
<a class="anchor" id="a362b7513eba83170d18d98946bc01d87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QuienEsQuien::QuienEsQuien </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQuienEsQuien.html">QuienEsQuien</a> &amp;&#160;</td>
          <td class="paramname"><em>quienEsQuien</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor de copia. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">quienEsQuien</td><td><a class="el" href="classQuienEsQuien.html" title="T.D.A. QuienEsQuien. ">QuienEsQuien</a> a copiar. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Documentación de las funciones miembro</h2>
<a class="anchor" id="a420bdb4aa9eafeac062279e3968f8f1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QuienEsQuien::ajuste_nodos_nulos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo para ajustar los hijos nulos. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>nodo sobre el que trabajare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>valor booleano que sera true si he modificado el arbol, false si no he realizado nada.</dd></dl>
<p>Metodo con mas "chicha" sobre como eliminar nodos redudantes. Y que mas dolor de cabeza me ha traido. Mi implementacion consiste en lo siguiente: Voy a comprobar si mi nodo "n" tiene algun hijo nulo. Si lo tiene, y ademas ese nodo no es el root (imposible que lo sea ademas, pero puede pasar), compruebo si ese nodo es hijo izquierdo o derecho de su padre. Dependiendo de la opcion, ahora compruebo cual de sus hijos es nulo, cambio dicho hijo por su padre usando los metodos prune e insert, y cambio el valor booleano de control a true (creado inicialmente a false).</p>
<p>En caso que se de que el nodo root tenga un hijo nulo, el prune lo hago de otra forma, si subirme a la posicion padre del root(), ya que no existe.</p>
<p>Este metodo devuelve el valor booleano que sera utilizado por la funcion eliminar_nodos_redundantes(node). </p>

</div>
</div>
<a class="anchor" id="a39024ba42b698f04960add57b177aa9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QuienEsQuien::contar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node&#160;</td>
          <td class="paramname"><em>nodo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo para contar el numero de nodos a partir de un nodo. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodo</td><td>el nodo desde el que quiero empezar a contar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>total numero de nodos</dd></dl>
<p>Aunque ya tiene uno bintree, como es privado y no quiero tocar ese fichero, voy a crearme uno propio.</p>
<p>Se utilizara para calcular la profundiad promedio. </p>

</div>
</div>
<a class="anchor" id="a94094336e901975020d712a2bfc2b963"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbintree.html">bintree</a>&lt;<a class="el" href="classPregunta.html">Pregunta</a>&gt; QuienEsQuien::crear_arbol_mejorado </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funcion que crea un nuevo arbol mejorado. Para ello, utiliza la entropia del tablero para crear un nuevo arbol. Cada pregunta que se crea nuevamente, dependera del valor booleano y de la entropia de los valores que queden, que no hayan sido usados. Para ello, al contrario de como hice el arbol normal, use estructuras auxiliares. Para hacer uso de esto, ademas implemente varios metodos adicionales: posicion_entropia(matriz,atri), hijo_izquierda(matriz,posicion,atri,n,per), hijo_izquierda(matriz,posicion,atri,n,per); NOTA: Podria haber hecho una funcion para llamar a estos dos ultimos metodos. Por falta de tiempo, junto a otros, lo he dejado asi. </p>
<dl class="section return"><dt>Devuelve</dt><dd>El nuevo arbol mejorado </dd></dl>

</div>
</div>
<a class="anchor" id="a0af1faf763f8f96ee2f346928b256460"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QuienEsQuien::eliminar_jugador </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>nombre</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo que elimina un jugador pasado por parametro de un arbol. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">nombre</td><td>El nombre del jugador que deseo eliminar</td></tr>
  </table>
  </dd>
</dl>
<p>Lo que hace este metodo es buscar el vector de atributos en el tablero que corresponde a dicho personaje. Si no lo encuentra, mostrara que no existe. En caso de que lo encuentre, voy a hacer un recorrido iterativo desde la Raiz del arbol con ese vector booleano. Cuando llegue al hijo, insertara como padre la otra rama. Para eso, utiliza la funcion prune, e inserta en el nodo padre de este la nueva rama.</p>
<p>Adicionalmente reduce el numero de jugadores del nodo padre en 1. NOTA IMPORTANTE: Este metodo no funciona correctamente con la VERSION MEJORADA </p>

</div>
</div>
<a class="anchor" id="a010586f119ad0966d35c64382a64e3bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QuienEsQuien::eliminar_nodos_redundantes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo que modifica el arbol de preguntas para que haya preguntas redundantes. </p>
<dl class="section post"><dt>Postcondición</dt><dd>El arbol de preguntas se modifica.</dd></dl>
<p>Esta funcion llama a eliminar_nodos_redundantes(arbol.root()). </p>

</div>
</div>
<a class="anchor" id="a0868e2c4013917db4cd79474c42e0386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QuienEsQuien::eliminar_nodos_redundantes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo que modifica el arbol de preguntas para que haya preguntas redundantes. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>nodo sobre el que actuara. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondición</dt><dd>El arbol de preguntas se modifica.</dd></dl>
<p>A diferencia de su version sin parametro, esta recibe un nodo, y comprueba si ese nodo es nulo. En caso de que no lo sea, ajustara los nodos nulos que tenga. En caso de que lo tenga, vuelvo a ejecutarse el mismo proceso desde el root() del arbol (el motivo es que cuando haga el ajuste, puede que aparezcan nuevos nodos nulos, he de volver a comprobar desde arriba). Si no puedo ajustar, compruebo a partir de los nodos izquierda y derecha.</p>
<p>NOTA: Dado que he estado solo, tuve que pedir ayuda a otros compañeros sobre este metodo. </p>

</div>
</div>
<a class="anchor" id="a8ca83ec923ee214026bdae93989063e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QuienEsQuien::esta_vector </td>
          <td>(</td>
          <td class="paramtype">vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>prueba</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo auxiliar usando por insertar_jugador que comprueba si un vector booleano existe o no en el tablero. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">prueba</td><td>el vector que deseo buscar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>esta a true o false si existe</dd></dl>
<p>Lo que hace es buscar este vector en el tablero que teniamos. Dada la estructura del tablero, puedo comprobar cada fila con este vector usando un iterador que recorre todas las posiciones con el vector. Si lo encuentra, devuelve true, en caso contrario, false. </p>

</div>
</div>
<a class="anchor" id="a08e83a35f30d0f8a7bd171c58db182a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QuienEsQuien::hijo_derecha </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; bool &gt;&gt;&#160;</td>
          <td class="paramname"><em>matriz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posicion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt;&#160;</td>
          <td class="paramname"><em>atri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt;&#160;</td>
          <td class="paramname"><em>per</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo que inserta un hijo en la derecha. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">posicion</td><td>la posicion del atributo con mejor entropia </td></tr>
    <tr><td class="paramname">matriz</td><td>la matriz que tengo actualmente </td></tr>
    <tr><td class="paramname">atri</td><td>el vector de atributos que tengo actualmente </td></tr>
    <tr><td class="paramname">n</td><td>el nodo de pregunta en el que estamos </td></tr>
    <tr><td class="paramname">per</td><td>vector de personajes que tengo actualmente</td></tr>
  </table>
  </dd>
</dl>
<p>Metodo analogo al de izquierda. Realiza lo mismo, pero en la parte derecha NOTA: Podria haber hecho un metodo que hiciese ambas cosas a la vez. Pero no se me ha ocurrido como, ni tengo tiempo. Estoy haciendo todo esto solo, y no dispongo de mas tiempo. Siento mucho que la implementacion sea tan "guarra", pero no se que hacer ya con tan poco tiempo. </p>

</div>
</div>
<a class="anchor" id="a54b6b326775cc6f4967cd50b31736fc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QuienEsQuien::hijo_izquierda </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; bool &gt;&gt;&#160;</td>
          <td class="paramname"><em>matriz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posicion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt;&#160;</td>
          <td class="paramname"><em>atri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt;&#160;</td>
          <td class="paramname"><em>per</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo que inserta un hijo en la izquierda. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">posicion</td><td>la posicion del atributo con mejor entropia </td></tr>
    <tr><td class="paramname">matriz</td><td>la matriz que tengo actualmente </td></tr>
    <tr><td class="paramname">atri</td><td>el vector de atributos que tengo actualmente </td></tr>
    <tr><td class="paramname">n</td><td>el nodo de pregunta en el que estamos </td></tr>
    <tr><td class="paramname">per</td><td>vector de personajes que tengo actualmente</td></tr>
  </table>
  </dd>
</dl>
<p>Lo que hace esta funcion en primer lugar es pelar dicha matriz, usando para ello la posicion el valor "0", junto a "matriz" y atributos. Usa 0 porque esta a la izquierda. Guarda la nueva matriz en una variable llamada "nueva". Despues, usando esa nueva matriz, si hay varios personajes y atributos (usa el numero de filas de la nueva matriz y el tamaño de "atri"), busca el de mayor entropia, y lo inserta. Si solo hay un atributo, pero uno o dos (no puede haber mas debido a la implementacion), añadira estos personajes manualmente. En caso que haya varios atributos pero un personaje solo, añade ese personaje directamente.</p>
<p>Para ahorrarme problemas, copio el vector de atributos a otro, llamado "a". De dicho vector, le quito los atributos insertados. Si siguen quedando, ejecuto por derecha e izquierda.</p>
<p>En caso de que aun haya personajes que añadir, ejecuto recursivamente este metodo y el de la parte derecha, con los nuevos objetos creados. </p>

</div>
</div>
<a class="anchor" id="abab84d08b95044e18858aae863337ea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;string,string&gt; QuienEsQuien::info_jugada </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>valor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo que devuelve un par de valores con la informacion de la jugada actual. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>nodo en cuestion que hemos consultado </td></tr>
    <tr><td class="paramname">valor</td><td>decision escogida </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>pair con los string del atributo y su respuesta (si/no)</dd></dl>
<p>Este metodo se encarga de recibir un nodo y lo que hemos respondido, y devolver un pair de la forma pair&lt;string, string&gt; con el nombre del del atributo y su contestacion. Todos estos pair, como dije, se almacenan en el metodo jugar, dentro de un vector&lt;pair&lt;string,string&gt;&gt;, el cual se va recorriendo cada vez que he jugado. </p>

</div>
</div>
<a class="anchor" id="a16816dd39d95ad489e44469f89fabbd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;string&gt; QuienEsQuien::informacion_jugada </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node&#160;</td>
          <td class="paramname"><em>jugada_actual</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dado un estado del tablero devuelve los nombres de los personajes que aun no han sido tumbados en el tablero. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">jugada_actual</td><td>Nodo del estado del tablero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Conjunto de personajes que no han sido tumbados en el tablero.</dd></dl>
<dl class="section pre"><dt>Precondición</dt><dd>El arbol del <a class="el" href="classQuienEsQuien.html" title="T.D.A. QuienEsQuien. ">QuienEsQuien</a> receptor debe haber sido construido previamente. </dd>
<dd>
El nodo indicado debe ser un nodo del arbol del <a class="el" href="classQuienEsQuien.html" title="T.D.A. QuienEsQuien. ">QuienEsQuien</a> receptor.</dd></dl>
<p>Devuelve un set con todos los personajes que aun son hijos de ese nodo. Es decir, cuando llego a un nodo, busco todos las hojas que hay a partir de ese nodo y las voy insertando en un set. Realizo este proceso recursivamente para buscar y almaceno el resultado en un set. Para hacer esto he declarado el union_jugadas.</p>
<p>Finalmente obtendre un set con todos los jugadores/nodos hojas a partir de ese nodo </p>

</div>
</div>
<a class="anchor" id="a381bcd553e7c0231bb1f33e67ae3c653"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QuienEsQuien::iniciar_juego </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inicializa el juego. </p>
<dl class="section post"><dt>Postcondición</dt><dd>Si la partida anterior no haba terminado se pierde el progreso. He creado un "robot" llamado Monika, el cual te hara preguntas. Dependiendo de la respuesta, preguntara por un nuevo atributo o encontrara el personaje. </dd></dl>

</div>
</div>
<a class="anchor" id="aa15de9675449659e796f66e6f3ca81d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QuienEsQuien::insertar_jugador </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>nombre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>nuevo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo para insertar un jugador a mi arbol. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">nombre</td><td>el jugador que quiero insertar </td></tr>
    <tr><td class="paramname">nuevo</td><td>el vector de decisiones, que corresponde a los parametros</td></tr>
  </table>
  </dd>
</dl>
<p>Este metodo se encargara de buscar el nodo, mientras no tenga hijos nulos, usando el vector booleano. Cuando llega a esa posicion, que SIEMPRE SERA una hoja, cojo esa hoja, la guardo en una funcion auxiliar. Vuelvo al nodo padre e inserto ambos hijos. Dado a la implementacion, el nuevo jugador no tendra los mismos atributos que el que ya existia. Por ello inserto ese nuevo jugador en la parte que corresponda, y el otro que ya teniamos, en la otra. Ademas el atributo de ese nodo padre sera ahora el que corresponda de mi vector de atributos, el cual me he ido desplazando a la vez que me desplazaba por el arbol. NOTA IMPORTANTE: Este metodo no funciona correctamente con la VERSION MEJORADA debido a como estan organizados los atributos en el otro </p>

</div>
</div>
<a class="anchor" id="ae7a4139787934cca03996687460935dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQuienEsQuien.html">QuienEsQuien</a>&amp; QuienEsQuien::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQuienEsQuien.html">QuienEsQuien</a> &amp;&#160;</td>
          <td class="paramname"><em>quienEsQuien</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sobrecarga del operador de asignacion. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">quienEsQuien</td><td>objeto a copiar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Referencia al objeto copiado. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b183ac890b8aefa1008e54fcd2704d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;bool&gt; &gt; QuienEsQuien::pelador </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; bool &gt;&gt;&#160;</td>
          <td class="paramname"><em>matriz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posicion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>valor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>per</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Se encarga de crear una nueva matriz a partir de otra, la posicion del valor, el valor en cuestion (0 o 1) y un vector de persojes. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">matriz,es</td><td>la matriz original que queremos editar </td></tr>
    <tr><td class="paramname">posicion,la</td><td>posicion del valor en la matriz </td></tr>
    <tr><td class="paramname">valor,el</td><td>valor que queremos buscar. Eliminamos aquellas filas a partir de la posicion que no sea de este valor. </td></tr>
    <tr><td class="paramname">per,es</td><td>un vector de personajes del que se eliminara los personajes a la vez que se eliminan las filas del tablero. Se elimina el personaje correspondiente. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>La nueva matriz "pelada".</dd></dl>
<p>Dicha funcion buscara la posicion en la nueva matriz, y se quedara con las filas cuyo valor, en la posicion que le hemos pasado por parametro, sea el indicado por parameto. Adicionalmente borra los personajes a los que corresponden esas filas de valores. Tambien borra la columna. Devuelve la nueva matriz. </p>

</div>
</div>
<a class="anchor" id="a0444a0f0d2f9afcb92df87ced126a42c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QuienEsQuien::posicion_entropia </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; bool &gt;&gt;&#160;</td>
          <td class="paramname"><em>matriz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt;&#160;</td>
          <td class="paramname"><em>atri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo que devuelve la posicion del atributo con mejor entropia. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">matriz</td><td>tablero donde se aplicara la entropia </td></tr>
    <tr><td class="paramname">atri</td><td>vector de los atributos correspondientes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Devuelve la posicion del atributo con mejor entropia.</dd></dl>
<p>Lo he diseñado asi dado que cuando obtenga la posicion del atributo con mejor entropia, creare el nuevo objeto <a class="el" href="classPregunta.html" title="En cada estructura pregunta se almacena la cadena de la pregunta y el número de personajes que aún no...">Pregunta</a> con la posicion de este atributo. Le paso ademas un array de atributos dado a que, como dije, estoy usando estructuras auxiliares, por lo que el vector de atributos sera diferente cada vez, por lo que hay que actuar sobre uno nuevo cada vez. </p>

</div>
</div>
<a class="anchor" id="ae999ad6c20f9ebf6a710060b99741126"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float QuienEsQuien::profundidad_promedio_hojas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Este metodo permite calcular la media de la profundidad de las hojas del arbol. Este valor representa el numero (promedio) de preguntas necesarias para adivinar cada personaje. A menor profundidad promedio, mejor solucion. Esta metrica es un indicador para evaluar la calidad de vuestra solucion. </p>
<dl class="section return"><dt>Devuelve</dt><dd>Profundidad media del arbol de preguntas.</dd></dl>
<dl class="section pre"><dt>Precondición</dt><dd>El arbol de preguntas debe haber sido construido previamente.</dd></dl>
<p>Como se vio en teoria, la profundidad promedia se calcula como la suma de profundidades totales (para ello uso el metodo <a class="el" href="classQuienEsQuien.html#a1535e054736d9920e8859b21697e372e" title="Metodo para obtener el total de profundidades de cada nodo. ">total_profundidad()</a>) entre el numero total de nodos (aunque ya tiene uno bintree, como esta privado y no quiero tocar el fichero para nada, voy a crear y usar el metodo <a class="el" href="classQuienEsQuien.html#a39024ba42b698f04960add57b177aa9f" title="Metodo para contar el numero de nodos a partir de un nodo. ">contar()</a>) </p>

</div>
</div>
<a class="anchor" id="ac0763b7ac0c24a3c54c2affaabe1f017"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QuienEsQuien::tablero_aleatorio </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numero_de_personajes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rellena los datos del <a class="el" href="classQuienEsQuien.html" title="T.D.A. QuienEsQuien. ">QuienEsQuien</a> con un tablero calculado aleatoriamente. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">numero_de_personajes</td><td>Numero de personajes que tiene el tablero a crear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b283af407756659fb75fba1725f84c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QuienEsQuien::tengo_hijos_nulos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo auxiliar para comprobar si un nodo tiene hijos nulos. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>nodo que quiero comprobar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>valor booleano que sera falso si no tiene, true si tiene alguno</dd></dl>
<p>Este metodo sera usado para comprobar si un hijo tiene algun hijo nulos para eliminar hijos redundantes. </p>

</div>
</div>
<a class="anchor" id="a1535e054736d9920e8859b21697e372e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QuienEsQuien::total_profundidad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;::node&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>acum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo para obtener el total de profundidades de cada nodo. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>nodo al que quiero calcular la profundidades  acum total de "pronfundidades", que ira aumentando</td></tr>
  </table>
  </dd>
</dl>
<p>Este metodo se encarga de calcular el total de profundidad del arbol que se calcula como la suma de la profundidad de todos los nodos.</p>
<p>Se utilizara para calcular la profundiad promedio. </p>

</div>
</div>
<a class="anchor" id="a60fd517d09369436bcfc6914dd964e6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;string&gt; QuienEsQuien::union_jugadas </td>
          <td>(</td>
          <td class="paramtype">set&lt; string &gt;&#160;</td>
          <td class="paramname"><em>primera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; string &gt;&#160;</td>
          <td class="paramname"><em>segunda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo auxiliar, utilizado para unir dos set. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">primera</td><td>El primer set </td></tr>
    <tr><td class="paramname">segunda</td><td>El segundo set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>union La union de las dos jugadas</dd></dl>
<p>Implemento este metodo dado a que informacion_jugada obtendra una jugada, pero quiero un conjunto de jugadas. Por eso voy uniendo cada nueva jugada al resto de jugadas. </p>

</div>
</div>
<a class="anchor" id="a0949bd026c2beeaacbf36fd0ba6fc3a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QuienEsQuien::usar_arbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbintree.html">bintree</a>&lt; <a class="el" href="classPregunta.html">Pregunta</a> &gt;&#160;</td>
          <td class="paramname"><em>arbol_nuevo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sustituye el arbol actual por el arbol pasado por parmetro. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">arbol_nuevo</td><td>Arbol de preguntas que sustituye al actual.</td></tr>
  </table>
  </dd>
</dl>
<p>Para crear el arbol he hecho un proceso recursivo. En primer lugar creo el arbol cuya raiz es el primer atributo del vector de atributos. Ahora empiezo a moverme. Si es 0, me muevo a hijo izquierda; si es 1, me muevo al hijo derecha. Ahi inserto el siguiente atributo. Asi hasta llegar al final, donde insertare el personaje correspondiente, es decir, el primero de la lista de personajes. Repito el proceso con el resto de filas, de nuevo, desde el root. Pero hay que tener algo en cuenta: si el nodo ya existe, NO SE AÑADE NADA. Este proceso va bien, pero hay un pequeño problema, ¿como calculo el numero de hijos antes de insertar nada?</p>
<p>La primera idea que tuve fue la de insertar un numero de hijos de tamaño 2, salvo que no sea el ultimo, y luego hacer otro recorrido e ir editandolo. Pero he tenido una idea mejor, donde solo he de recorrer el arbol la mitad de veces. Cuando leo un vector para insertar un nodo, dicho vector booleano lo compruebo compruebo con los que le quedan "por debajo", es decir, los que hay desde la posicion donde esta el hasta el final.</p>
<p>Dicho de otra forma, voy a crear un iterador a la posicion de ese vector, y lo voy a comprobar a los que hay desde ese hasta el final. Pero no voy a comprobar el vector entero, sino que cada vez lo comparo hasta la posicion de dicho atributo. Es decir: Si tengo un vector [0 1 1] y lo que voy a añadir es el primer atributo, el que vale a "0" en este vector, he de comprobar cuantos tienen tambien como primera decision "0", para el siguiente atributo tengo que buscar cuantos empiezan por "01", para el siguiente "011"... La cantidad de vectores que empiecen por eso que coincidan, seran el numero de hijos.</p>
<p>Esto puede provocar un error, ya que puedo añadir un nodo que ya exista con menor si hago esto... Pero dado a como busco el arbol, desde el primero al ultimo, y dado que no puedo añadir nodos a posiciones donde ya hay uno, esto funciona correctamente. Me explico: supongo que recorro el primer vector y ya he hecho un primer recorrido. Con eso tengo un nodo X que tiene 3 hijos. Ahora haciendo el segundo recorrido para el segundo vector, me sale ese mismo nodo con 2 hijos. No puedo añadirlo porque ya existia uno antes. Ademas, dada esta expliracion, siempre se añaden los nodos con el numero de hijos correcto. </p>

</div>
</div>
<h2 class="groupheader">Documentación de las funciones relacionadas y clases amigas</h2>
<a class="anchor" id="a0fd056740c595bda2964d68dc262a639"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuienEsQuien.html">QuienEsQuien</a> &amp;&#160;</td>
          <td class="paramname"><em>quienEsQuien</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operador de insercion de flujo. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream de salida </td></tr>
    <tr><td class="paramname">quienEsQuien</td><td>Quien es quien a escribir. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Referencia al stream de salida.</dd></dl>
<p>Escribe en <em>is</em> un quien es quien. El formato usado para la escritura es un TSV (tab-separated values) en el que las columnas tienen cabecera y son las preguntas. La ultima columna corresponde al nombre del personaje. Tras la cabecera se especifica en cada linea un personaje, teniendo el valor 1 o 0 si tiene/no tiene el atributo de la columna. En la ultima columna se da el nombre del personaje. </p>

</div>
</div>
<a class="anchor" id="a2d1e36c1b1d93621e8544d645cfff44c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuienEsQuien.html">QuienEsQuien</a> &amp;&#160;</td>
          <td class="paramname"><em>quienEsQuien</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operador de extraccion de flujo. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Stream de entrada </td></tr>
    <tr><td class="paramname">quienEsQuien</td><td>Quien es quien a leer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Referencia al stream de entrada.</dd></dl>
<p>Lee de <em>is</em> un quien es quien y lo almacena en <em>quienEsQuien</em>. El formato aceptado para la lectura es un TSV (tab-separated values) en el que las columnas tienen cabecera y son las preguntas. La ultima columna corresponde al nombre del personaje. Tras la cabecera se especifica en cada lnea un personaje, teniendo el valor 1 o 0 si tiene/no tiene el atributo de la columna. En la ultima columna se da el nombre del personaje. </p>

</div>
</div>
<hr/>La documentación para esta clase fue generada a partir del siguiente fichero:<ul>
<li>include/<a class="el" href="quienesquien_8h_source.html">quienesquien.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generado por &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
